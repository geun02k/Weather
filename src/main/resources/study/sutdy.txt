<날씨 일기 프로젝트>
날씨를 저장하고 일기를 작성할 수 있다.


=============================== << 날씨 데이터 고르기 >> ===============================
<날씨 데이터 고르기>
1. 네이버에서 검색
	: 네이버에서 '서울 날씨' 검색 결과를 크롤링 해오는 방법
	  온도, 강수확률, 습도, 바람세기 등의 데이터 긁어올 수 있음.
	  하지만 이 데이터는 기상청에서 제공해주는 데이터를 나타내주는 것이므로
	  기존 기상청에서 제공해주는 데이터를 활용하는 게 좋을 수 있다.
2. 기상청 데이터
	: 내가 스스로 얻을 수 없는 정보들을 국가, 기업, 기관 등에서 해당 정보를 open api로 제공해준다.
	  공공데이터포털에서 기상청 api를 사용할 수 있다.
	  (공공데이터포털에서는 기상청 외의 데이터들도 준비되어있다.)
	  하지만 기상청데이터는 국내 데이터에 한정해서 제공하고 있다.
	  우리가 제공하려는 프로그램은 글로벌한 사용자를 타겟으로 할 수도 있다.
3. OpenWeatherMap Api
	: 세계적 날씨 정보를 제공하는 날씨 api
	  (해외날씨정보를 가져오고 싶어서 구글에서 free weather api로 검색한 결과로 얻은 정보.
	   사용하고자 하는 api가 있다면 구글에서 검색하면 찾을 수 있다.
	   유료 api도 있기 때문에 free로 검색.)
	: 부분적으로 무료 (1분에 60번 호출까지 무료)


<선택한 api의 사용 적합성 확인>
추후 api 종류를 변경하는 일은 어렵다.
따라서 의문사항이 생긴 것들은 api document를 통해 모두 해소를 해야한다.
- current weather data api document
  https://openweathermap.org/current

1. 제공데이터 확인하기
OpenWeatherMap Api를 사용하기로 결정한 후 해당 api를 정말 사용해도 되는지를 확인해야 한다.
OpenWeatherMap 사이트를 확인해보니 현재날씨데이터, 미래날씨예측데이터, 과거날씨데이터를 제공하고 있음을 알 수 있다.
날씨일기를 작성하기 위해서는 현재날씨와 과거날씨 정보가 필요하기에 프로젝트를 만들기위해 필요한 데이터를 제공하고있음을 알았다.
api의 세부 설명을 읽어보니 200,000 개의 도시 데이터를 제공하고 있다.
따라서 부분적 무료이고 20만개의 도시 데이터를 제공하고 있으니 사용하기 적합함을 알 수 있다.

2. api 호출방법 확인하기
api 사용 이전에 체크해야할 사항이 한가지 더 있다.
api가 사용하기 편한지도 확인이 필요하다. api는 정해진 사용 방법이 있기 때문이다. 이는 api document에 명시되어있다.
위도, 경도, api key 정보만 있으면 api에 데이터를 요청할 수 있다. (얻기에 쉬운 데이터이니 적합.)
위도와 경도가 아닌 도시 이름으로 날씨를 얻을 수는 없을까?
api document에 city를 검색하니 request by city name 이라고 도시명으로 요청을 할 수 있음을 알았다.

3. api 응답결과 확인하기
api 호출 결과가 쓸만한지 확인해야 한다.
api document에서 Fields in API response를 확인하면 알 수 있다. (response를 검색해 찾아냄.)
weather.main을 확인하니 비, 눈, 흐림 등의 데이터를 제공한다.
main에서는 체감온도, 습도, 온도 등의 데이터를 제공한다.
따라서 response에서 쓸만한 데이터가 있는 것도 확인했고 응답형식도 json 혹은 xml로 무난함을 알 수 있다.


<오픈API와 API Key>
- API 인증 (Authentication)
    : API를 호출하는 대상을 확인하는 절차
- API 인증방식
    : 방식에 따라 구현 난이도와 보완 수준이 달라진다.
    1. API Key 방식 : OpenWeatherMap api에서 사용하는 방식
    2. API Token 방식
- API Key (https://home.openweathermap.org/api_keys)
    : 특정 사용자만 알 수 있는 문자열로 구성
    : 개발자는 API 제공처에서 API Key를 발급
        -> API 호출 시 API Key를 메시지 안에 넣어 호출
        -> 서버는 메시지 안에서 API Key를 읽어들여 누가 호출한 API인지 인증
    : OpenWeatherMap API는 1분에 60번 호출까지 무료이다.
      따라서 악용되어 과금될 수 있으니 API 사용처를 인증하는 API Key는 어딘가에 업로드 하지말고 보관해야 한다.
      (git에도 업로드하면 안된다는데 그럼 어떻게 키를 불러서 호출하지?)
    ex) Request Header {
            api-key: "1231231241242144"
        }


<OpenWeatherMap API 사용방법>
- API 호출방식
    https://api.openweathermap.org/data/2.5/weather?q={city name}&appid={API key}
- seoul의 응답결과
{
    "coord": {
        "lon": 126.9778,
        "lat": 37.5683
    },
    "weather": [
        {
            "id": 800,
            "main": "Clear",
            "description": "clear sky",
            "icon": "01n"
        }
    ],
    "base": "stations",
    "main": {
        "temp": 270.91,
        "feels_like": 266.43,
        "temp_min": 270.91,
        "temp_max": 270.91,
        "pressure": 1024,
        "humidity": 69,
        "sea_level": 1024,
        "grnd_level": 1013
    },
    "visibility": 10000,
    "wind": {
        "speed": 3.6,
        "deg": 340
    },
    "clouds": {
        "all": 0
    },
    "dt": 1733574135,
    "sys": {
        "type": 1,
        "id": 8105,
        "country": "KR",
        "sunrise": 1733524421,
        "sunset": 1733559223
    },
    "timezone": 32400,
    "id": 1835848,
    "name": "Seoul",
    "cod": 200
}
- 예상 활용 정보
    - weather의 main, icon
    - main의 temp


<날씨 일기 저장 API 구현>
1. OpenWeahterMap에서 SpringBoot로 데이터 받아오기
2. 받아온 json 데이터 사용 가능하게 파싱하기
3. SpringBoot에서 DB로 데이터 저장하기
- client, controller, service, repository 간 데이터는 DTO로 주고받음
- repository와 DB는 Entity로 데이터 주고받음


<JSON Formatter>
크롬 확장 프로그램으로 크롬에서 API 호출 시 결과값이 json인 문자열에 대해서는 JSON형태에 맞도록 한 눈에 보기 쉽게 출력해줌.




=============================== << 프로젝트 구성 >> ===============================
<프로젝트 생성하기>
스프링부트 프로젝트는 정해진 구조가 있다.
springInitializar 또는 인텔리제이나 이클립스에서 베이스프로젝트를 자동생성해주는 기능을 사용하지 않으면
스프링부트 프로젝트에서 원하는 구조대로 폴더와 파일을 일일이 생성해야 한다.


<프로젝트 메타데이터>
빌드도구
: 라이브러리들의 관리 및 프로젝트의 빌드와 실행을 수행한다.
1. maven
2. gradle - 속도도 더 빠르고 코드의 양도 적다. / maven 보다 이후에 생겨남.

스프링부트 버전
1. SNAPSHOT : 신규기능이 추가된 버전
2. M1, M2 : Milestone으로 정식버전 이전에 좀 더 정리되어진 버전
3. 괄호없음 : 안정화된 정식 배포버전

Artifact : 프로젝트명

Packaging
: 어떤 패키지 구조를 선택하느냐에 따라 프로젝트의 구조가 조금 달라진다.
빌드 실행파일 확장자도 달라진다.
1. JAR (Java Archive) : API를 제공하는 서버만 생성할 때 사용.
2. WAR (Web Application Archive) : JAR + 웹 관련 자원 / HTML,JSP같은 웹 어플리케이션을 함께 만들 때 사용

자바버전
: 자바 버전별 LTS(Long Term Support) 기간이 상이하다.
  늦게 출시되었다고 LTS가 긴 것은 아니다.
  (강의에서 8버전 사용하는데 17이 긴지, 8을 아직까지 지원하는지 확인이 필요할듯....)

Dependency
: 스프링 프로젝트에서 사용할 라이브러리 선택.
1. Lombok : 반복코드(?)인 Getter, Setter같은 코드 자동생성 (코드 간결하게 해주는 마법사)
2. Spring Web : REST API 만들 때 필수 API


<프로젝트 구동>
build.gradle 파일을 선택해 프로젝트를 오픈한다.
해당 파일만 선택해도 intellij는 스프링부트 프로젝트임을 인식해 전체프로젝트를 불러온다.


<프로젝트 구조>
폴더 앞에 .이 붙어있으면 숨김파일임.
프로젝트의 임시정보, 구동시점에만 필요한 잠깐 쓰이는 정보를 담고있다.
해당 폴더, 파일에는 직접 접근해서 작업하거나 하는 일은 거의 없다.

.gradle : gradle이 동작할 때 필요한 정보를 담고있는 폴더
.idea : 인텔리제이가 구동 시점에 필요한 정보를 담고있는 폴더
.gitignore : github에 필요한 소스코드 파일만 올리기 위해 제외정보를 담고있는 파일 (빌드한 결과물, 내 환경설정파일 제외)
			 나와 같이 협업해 프로젝트를 이끌어가는 사람은 인텔리제이가 아닌 이클립스를 사용할수도 있고
			 같은 이클립스를 사용하더라도 내 컴퓨터에 필요한 설정파일을 올릴 필요가 없다. (.idea)
			 스프링부트 프로젝트 생성시 해당 파일에 일반적으로 git에 공유하지 않는 파일들은 제외되어 있다.

gradle : 빌드한 결과물을 담고있는 폴더
src : 소스코드 위치
src/main/java : 자바 파일 위치
src/main/resources : 자바 파일을 제외한 다른 형식의 파일들 위치
build.gradle : 빌드 구성 스크립트
			 : 이전에 선택한 의존성 등과 같은 스프링 부트 프로젝트의 빌드 관련 설정 정보를 담고있는 파일
gradlew, gradlew.bat : gradle 빌드 시 사용하는 파일 (개발자가 직접 수정할 일은 없다.)


<의존성주입>
implementation : 컴파일, 테스트 모든 시점에서 사용
compileOnly : 컴파일하는 시점에만 해당 라이브러리 사용
			 lombok 라이브러리를 컴파일 시점에만 사용하는 것은
			 어노테이션들을 컴파일 과정에서 getter, setter 등을 작성한 것과 동일하게 변경해주기 때문이다.
annotationProcessor :
testImplementation : 테스트 시점에만 사용

dependency들은 mavenCentral 에서 다운받는다.
회사에서 개발할 때는 라이브러리들을 사내에서 개발하기도 하고
보안정책이나 사내 시스템에 맞는 라이브러리들을 사용하는 경우도 있다.

이럴 때는 dependencies에 해당 라이브러리를 포함하고
repositories에 사내 저장소 이름도 작성해주어야한다. (그러면 다른 저장소에서도 라이브러리를 불러올 수 있다.)





=============================== << TDD >> ===============================
<TDD, 테스트주도개발>
- Test Driven Development
- 테스트를 먼저 만들고 테스트를 통과하기 위한 코드를 짜는 것
- 테스트 코드를 먼저 작성하면 개발의 목적성이 명확해져 요구사항을 세밀하게 정리할 수 있다는 장점이 있다.

1. 테스트코드 먼저 작성하기
2. 테스트코드를 pass 하는 코드 작성하기
3. 리팩터링하기
위의 3가지를 계속 반복한다.

<Junit>
테스트코드 작성시 많이 사용되는 라이브러리

- 많이 사용되는 메서드
1. assertSame(a,b) : 두 객체 자체가 같은지 비교
2. assertEquals(a,b) : 두 객체에 정의된 equals를 통해 비교
3. assertArrayEquals(a,b) : 두 배열이 일치함을 확인
4. assertTrue(a) : 참인지 확인
5. assertNotNull(a) : null이 아닌지 확인





=============================== << DB에서 작업하기 >> ===============================
<Persistence Framework - SQL Mapper / ORM>
- Persistencd (영속성)
  : 데이터를 생성했던 프로그램이 종료되더라도 데이터가 휘발되지 않는 것.

- Persistence Framework
	: 데이터를 생성했던 프로그램이 종료되더라도 데이터가 휘발되지 않도록 도와주는 프레임워크
	: DB와 연동되는 시스템을 빠르게 개발(Spring, DB연결)
	  Persistence Framework가 없다면 SpringBoot와 DB와 연결하는 부분을 직접 관리해야 한다.
	  db와의 연결여부, query의 이상여부에 따라 if-else문으로 분기처리해야한다.
	  또한 db와 연결이 되어있는지 계속 확인해야 하고
	  db와 연결여부에 따라 if-else 분기처리해야한다.
	  그리고 db 사용이 끝나면 연결을 직접 끊어주어야한다.
	: 안정적인 구동을 보장해주는 프레임워크
	- 재사용, 유지보수에 용이
	- 직관적인 코드

1. SQL Mapper
	- SQL을 개발자가 직접 작성
	- 매핑 : 쿼리수행결과 <-> 객체
	- 단점
		- DB종류 변경시 쿼리 수정 필요
		- 비슷한 쿼리 반복적 작성 필요 ex) select * from 테이블명 -> 테이블마다 조회쿼리 작성 반복

2. ORM (Object Relation Mapping)
	- Object와 DB 테이블 맵핑
	- java 메서드 사용 -> 자동 SQL 생성.
	- 매핑 : DB테이블 <-> 객체
	- 단점
		- 복잡한 쿼리를 자바 메서드 만으로 해결하는 것이 불편.


<JPA / JDBC>
1. JPA (Java Persistence API)
	- ORM의 한 종류로 Java에서 사용. (자바 ORM 기술의 표준 명세)
	- 객체와 테이블의 연결된 정보만 알려주면 쿼리를 대신 짜줌.

	Application			O/R Mapper			JDBC interface		JDBC Implementations	Persistence Layer
	Modules
	---------------------------------------------------------------------------------------------------------
	service
	->repository---------> Spring Data JPA
						   -> JPA
	->repository Impl----> Hibernate -------> JDBC Basic APIs ---> JDBC Driver			Database
									 -------> DataSource -------->
											  (Configuration for connection)

2. JDBC (Java Database Connectivity)
	: 자바에서 DB를 사용할 수 있도록 제공해주는 최소한의 API. (단순히 DB와 Java 연결)
	- SQL Mapper의 한 종류로 Java에서 사용.

	Application		JDBC interface		JDBC Implementations	Persistence Layer
	-----------------------------------------------------------------------------
	DTO				Spring JDBC			JDBC Driver				Database
					(ex> JdbcTemplate)

					DataSource
					(Configuration for connection)


<JDBC 사용하기>
1. build.gradle에 jdbc, mysql 관련 라이브러리 추가
   - implementation 'org.springframework.boot:spring-boot-starter-jdbc'
   - runtimeOnly 'com.mysql:mysql-connector-j'

2. application.properties 파일에 DB 접속정보 저장
   - 미설정 시 서버 실행 시 아래의 오류 발생
     Failed to configure a DataSource:
     'url' attribute is not specified and no embedded datasource could be configured.
   - 설정정보
     spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
     # ?serverTimezone=UTC&characterEncoding=UTF-8 설정은 optional한 부분
     # 데이터베이스의 시간대와 인코딩방식 설정
     spring.datasource.url=jdbc:mysql://localhost:3306/project?serverTimezone=UTC&characterEncoding=UTF-8
     spring.datasource.username=root
     spring.datasource.password=zerobase

3. MySQL에 데이터베이스, 테이블생성
   - Project 데이터베이스 생성
   - Memo 테이블 생성

4. 테이블과 매칭되는 자바 클래스 생성
   - Memo 테이블과 매칭되는 Memo.java 클래스(도메인) 생성

5. JdbcMemoRepository 생성
    - JDBC를 이용해 MySQL과 Spring 사이에 데이터 전송이 가능하도록 하기위해 저장소 생성.

6. 테스트코드 작성


<JPA 사용하기>
1. build.gradle 파일에 jpa 관련 라이브러리 추가
   - implementation 'org.springframework.boot:starter-data-jpa'

2. application.properties 파일에 DB 접속정보 저장
   - jdbc의 기존 접속정보를 유지하고 아래의 두 설정 추가
   - spring.jpa.show-sql=true
     : 쿼리 출력 여부 설정 (JPA는 쿼리를 자동생성해주기 때문에 출력해 확인 필요시 true)
   - spring.jpa.database=mysql
     : 어떤 데이터베이스를 쓰는지 작성

3. Memo 클래스에 @Entity 어노테이션을 사용해 Entity화 하기
   - JPA는 스프링부트의 클래스와 DB의 테이블을 매핑하는 것이다.
     이 때 테이블의 스프링부트의 여러 클래스들을 하나의 DB 테이블에 매핑시키는 경우도 있을 수 있다. (하나의 테이블에 여러 Entity 매핑가능)
     이런 경우에는 각각의 클래스들을 Entity로 지정해 테이블과 연결할 수 있다.
     따라서 클래스의 @Entity 어노테이션을 이용해 연결된 테이블과 사용할 값들을 명시해주게 된다.

     -> @Entity
     name 속성을 설정해주지 않고 @Entity만 사용하게 되면
     클래스명과 동일한 이름의 테이블과 매핑된다.
     -> @Entity(name="Memo")
        : Memo 테이블에 매핑된 Entity
        : name 속성에 클래스과 매핑할 테이블명을 작성한다.

     예를들면 어떤 Entity는 Memo 테이블의 id값만 사용하고 싶을 수 있다.
     그런 경우 id값만 가지는 Entity를 생성할 수 있다.
     그리고 id, text 정보를 모두 가지는 Entity를 또 생성할 수 있다.
     이렇게 활용 방안에 따라서 하나의 테이블에 대해 여러 Entity를 생성할 수도 있다.

     - @Id : 테이블의 pk 필드에 해당 어노테이션 필수 추가
     - @GeneratedValue : 값 자동증가 필드에 사용
                         아래는 strategy 속성의 값
                        - GenerationType.AUTO : 자동증가
                        - GenerationType.IDENTITY : 키 생성을 DB에 위임(스프링부트는 키생성x)
                        - GenerationType.SEQUENCE : 데이터베이스 Object를 만들어서 키 생성해줌
                        - GenerationType.TABLE : 키생성을 위한 테이블을 생성해 제공

4. Memo 클래스에 @Table 붙이기 (생략가능)
   - @Table(name="Memo")
     : @Entity에서 name 속성을 이용해 매핑 테이블을 지정하지 않고
       @Table 어노테이션을 추가로 이용해 매핑 테이블을 지정할 수도 있다.

5. JpaMemoRepository 구현
   - JpaRepository 클래스를 상속받아 해당 클래스를 생성하기만해도
     여태까지 JdbcMemoRepository에 작성했던 메서드들 호출이 가능하다.
     따라서 JdbcMemoRepository와 JpaMemoRepository의 코드 양의 차이가 확연히 들어난다.

   - JpaRepository
     JPA는 ORM의 자바 표준 명세이다.
     따라서 자바에서 ORM 개념을 활용할 때 쓸 메서드들은 JpaRepository에 이미 모두 정의가 되어있다.
     개발자는 그저 메서드를 가져와 사용하기만하면 된다.

   - JpaRepository<클래스, pk의타입>
     : 어떤 클래스를 가져와 연결할건지, 테이블의 pk 타입은 무엇인지 명시적으로 작성이 필요하다.

6. 테스트코드 작성
   - JpaMemoRepositoryTest.java inertMemoTest() 에서 아래와 같이 객체 생성 시 select문만 2번 출력하고 오류발생
        - 객체생성방법 : Memo newMemo = new Memo(1, "testText");
        - 오류 : Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect):
                    [zerobase.weather.domain.Memo#1]
                org.springframework.orm.ObjectOptimisticLockingFailureException:
                    Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect):
                    [zerobase.weather.domain.Memo#1]
        - 해결하는데 참고된 블로그 : https://programmer-chocho.tistory.com/80





=============================== << MVC패턴 >> ===============================
<Controller>
- @RestController : 기본 @Controller 어노테이션을 사용할 때와 달리
                    http 응답을 보낼 때 상태코드를
                    controller에서 지정해서 내려보낼 수 있게 해준다.
- @RequestParam : http 요청 url ? 뒤에 오는 데이터를 얻을 때 사용 (파라미터 형식)
                  ex) http://localhost/craete/diary?date=20241201
- @RequestBody : http 요청의 request body 부분의 정보 얻을 때 사용
- @DateTimeFormat : 데이터타입 포맷설정
                    날짜는 여러 형식으로 저장될 수 있기 때문에
                    받을 날짜 데이터의 포맷을 하나로 정의할 떄 사용
- 테스트
    1. 브라우저에서 요청 url을 작성해 테스트하는 방법
       해당 방식은 Get방식의 요청으로 인식한다.
       따라서 POST 같은 요청을 보내기에는 적합하지 않은 방법이다.
       브라우저는 요청으로 받아온 웹사이트 정보를 빨리빨리 서빙을 해줘야한다.
       따라서 브라우저는 기본으로 캐싱을 한다.
       그렇기에 api 요청 테스트를 할때는 현재 요청에 대한 결과값을 정확히 보고싶은데
       캐싱된 데이터의 영향을 받아서 예상과 다른 결과값이 나올 수 있기 때문에 적합하지 않다.
    2. Post Man 사용
       - 요청 url 작성란에 아래와 같이 host라는 변수를 url에 작성 시
         환경마다 host url을 다르게 지정해두면
         환경만 변경해 같은 url로 더 간편하게 테스트 가능
         http://{(host)}/create/diary?date=2022-05-12


<Service>
- @Value : import org.springframework.beans.factory.annotation.Value; (lombok의 @value 아님 주의)
           .properties 파일에 정의된(?) key에 대한 value값 가져오기

           - in DiaryService
             @Value 어노테이션을 사용해 apikey값을 가져오는 이유
             application.properties는
             지금 로컬환경이라는 단 하나의 환경에 대한 설정정보를 담고있지만
             실무 개발 시에는 로컬, 개발테스트, 운영환경과 같이 여러 환경이 존재한다.
             이 다양한 환경들은 같은 DB를 바라보지 않는다. 따라서 환경별로 다른 DB를 지정하게 된다.
             그런 환경 분리는 resource 폴더 아래의 properties 파일에서 properties를 환경마다 지정해주고
             코드상에서는 환경과 무관하게 아래와 같이 키값만 가지고 value를 불러올 수 있다.


<Repository>

<Domain>

