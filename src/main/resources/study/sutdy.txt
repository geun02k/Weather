<날씨 일기 프로젝트>
날씨를 저장하고 일기를 작성할 수 있다.


=============================== << 날씨 데이터 고르기 >> ===============================
<날씨 데이터 고르기>
1. 네이버에서 검색
	: 네이버에서 '서울 날씨' 검색 결과를 크롤링 해오는 방법
	  온도, 강수확률, 습도, 바람세기 등의 데이터 긁어올 수 있음.
	  하지만 이 데이터는 기상청에서 제공해주는 데이터를 나타내주는 것이므로
	  기존 기상청에서 제공해주는 데이터를 활용하는 게 좋을 수 있다.
2. 기상청 데이터
	: 내가 스스로 얻을 수 없는 정보들을 국가, 기업, 기관 등에서 해당 정보를 open api로 제공해준다.
	  공공데이터포털에서 기상청 api를 사용할 수 있다.
	  (공공데이터포털에서는 기상청 외의 데이터들도 준비되어있다.)
	  하지만 기상청데이터는 국내 데이터에 한정해서 제공하고 있다.
	  우리가 제공하려는 프로그램은 글로벌한 사용자를 타겟으로 할 수도 있다.
3. OpenWeatherMap Api
	: 세계적 날씨 정보를 제공하는 날씨 api
	  (해외날씨정보를 가져오고 싶어서 구글에서 free weather api로 검색한 결과로 얻은 정보.
	   사용하고자 하는 api가 있다면 구글에서 검색하면 찾을 수 있다.
	   유료 api도 있기 때문에 free로 검색.)
	: 부분적으로 무료 (1분에 60번 호출까지 무료)
	: 링크첨부필요

<선택한 api의 사용 적합성 확인>
추후 api 종류를 변경하는 일은 어렵다.
따라서 의문사항이 생긴 것들은 api document를 통해 모두 해소를 해야한다.

1. 제공데이터 확인하기
OpenWeatherMap Api를 사용하기로 결정한 후 해당 api를 정말 사용해도 되는지를 확인해야 한다.
OpenWeatherMap 사이트를 확인해보니 현재날씨데이터, 미래날씨예측데이터, 과거날씨데이터를 제공하고 있음을 알 수 있다.
날씨일기를 작성하기 위해서는 현재날씨와 과거날씨 정보가 필요하기에 프로젝트를 만들기위해 필요한 데이터를 제공하고있음을 알았다.
api의 세부 설명을 읽어보니 200,000 개의 도시 데이터를 제공하고 있다.
따라서 부분적 무료이고 20만개의 도시 데이터를 제공하고 있으니 사용하기 적합함을 알 수 있다.

2. api 호출방법 확인하기
api 사용 이전에 체크해야할 사항이 한가지 더 있다.
api가 사용하기 편한지도 확인이 필요하다. api는 정해진 사용 방법이 있기 때문이다. 이는 api document에 명시되어있다.
위도, 경도, api key 정보만 있으면 api에 데이터를 요청할 수 있다. (얻기에 쉬운 데이터이니 적합.)
위도와 경도가 아닌 도시 이름으로 날씨를 얻을 수는 없을까?
api document에 city를 검색하니 request by city name 이라고 도시명으로 요청을 할 수 있음을 알았다.

3. api 응답결과 확인하기
api 호출 결과가 쓸만한지 확인해야 한다.
api document에서 Fields in API response를 확인하면 알 수 있다. (response를 검색해 찾아냄.)
weather.main을 확인하니 비, 눈, 흐림 등의 데이터를 제공한다.
main에서는 체감온도, 습도, 온도 등의 데이터를 제공한다.
따라서 response에서 쓸만한 데이터가 있는 것도 확인했고 응답형식도 json 혹은 xml로 무난함을 알 수 있다.





=============================== << 프로젝트 구성 >> ===============================
<프로젝트 생성하기>
스프링부트 프로젝트는 정해진 구조가 있다.
springInitializar 또는 인텔리제이나 이클립스에서 베이스프로젝트를 자동생성해주는 기능을 사용하지 않으면
스프링부트 프로젝트에서 원하는 구조대로 폴더와 파일을 일일이 생성해야 한다.


<프로젝트 메타데이터>
빌드도구
: 라이브러리들의 관리 및 프로젝트의 빌드와 실행을 수행한다.
1. maven
2. gradle - 속도도 더 빠르고 코드의 양도 적다. / maven 보다 이후에 생겨남.

스프링부트 버전
1. SNAPSHOT : 신규기능이 추가된 버전
2. M1, M2 : Milestone으로 정식버전 이전에 좀 더 정리되어진 버전
3. 괄호없음 : 안정화된 정식 배포버전

Artifact : 프로젝트명

Packaging
: 어떤 패키지 구조를 선택하느냐에 따라 프로젝트의 구조가 조금 달라진다.
빌드 실행파일 확장자도 달라진다.
1. JAR (Java Archive) : API를 제공하는 서버만 생성할 때 사용.
2. WAR (Web Application Archive) : JAR + 웹 관련 자원 / HTML,JSP같은 웹 어플리케이션을 함께 만들 때 사용

자바버전
: 자바 버전별 LTS(Long Term Support) 기간이 상이하다.
  늦게 출시되었다고 LTS가 긴 것은 아니다.
  (강의에서 8버전 사용하는데 17이 긴지, 8을 아직까지 지원하는지 확인이 필요할듯....)

Dependency
: 스프링 프로젝트에서 사용할 라이브러리 선택.
1. Lombok : 반복코드(?)인 Getter, Setter같은 코드 자동생성 (코드 간결하게 해주는 마법사)
2. Spring Web : REST API 만들 때 필수 API


<프로젝트 구동>
build.gradle 파일을 선택해 프로젝트를 오픈한다.
해당 파일만 선택해도 intellij는 스프링부트 프로젝트임을 인식해 전체프로젝트를 불러온다.


<프로젝트 구조>
폴더 앞에 .이 붙어있으면 숨김파일임.
프로젝트의 임시정보, 구동시점에만 필요한 잠깐 쓰이는 정보를 담고있다.
해당 폴더, 파일에는 직접 접근해서 작업하거나 하는 일은 거의 없다.

.gradle : gradle이 동작할 때 필요한 정보를 담고있는 폴더
.idea : 인텔리제이가 구동 시점에 필요한 정보를 담고있는 폴더
.gitignore : github에 필요한 소스코드 파일만 올리기 위해 제외정보를 담고있는 파일 (빌드한 결과물, 내 환경설정파일 제외)
			 나와 같이 협업해 프로젝트를 이끌어가는 사람은 인텔리제이가 아닌 이클립스를 사용할수도 있고
			 같은 이클립스를 사용하더라도 내 컴퓨터에 필요한 설정파일을 올릴 필요가 없다. (.idea)
			 스프링부트 프로젝트 생성시 해당 파일에 일반적으로 git에 공유하지 않는 파일들은 제외되어 있다.

gradle : 빌드한 결과물을 담고있는 폴더
src : 소스코드 위치
src/main/java : 자바 파일 위치
src/main/resources : 자바 파일을 제외한 다른 형식의 파일들 위치
build.gradle : 빌드 구성 스크립트
			 : 이전에 선택한 의존성 등과 같은 스프링 부트 프로젝트의 빌드 관련 설정 정보를 담고있는 파일
gradlew, gradlew.bat : gradle 빌드 시 사용하는 파일 (개발자가 직접 수정할 일은 없다.)


<의존성주입>
implementation : 컴파일, 테스트 모든 시점에서 사용
compileOnly : 컴파일하는 시점에만 해당 라이브러리 사용
			 lombok 라이브러리를 컴파일 시점에만 사용하는 것은
			 어노테이션들을 컴파일 과정에서 getter, setter 등을 작성한 것과 동일하게 변경해주기 때문이다.
annotationProcessor :
testImplementation : 테스트 시점에만 사용

dependency들은 mavenCentral 에서 다운받는다.
회사에서 개발할 때는 라이브러리들을 사내에서 개발하기도 하고
보안정책이나 사내 시스템에 맞는 라이브러리들을 사용하는 경우도 있다.

이럴 때는 dependencies에 해당 라이브러리를 포함하고
repositories에 사내 저장소 이름도 작성해주어야한다. (그러면 다른 저장소에서도 라이브러리를 불러올 수 있다.)





=============================== << TDD >> ===============================
<TDD, 테스트주도개발>
- Test Driven Development
- 테스트를 먼저 만들고 테스트를 통과하기 위한 코드를 짜는 것
- 테스트 코드를 먼저 작성하면 개발의 목적성이 명확해져 요구사항을 세밀하게 정리할 수 있다는 장점이 있다.

1. 테스트코드 먼저 작성하기
2. 테스트코드를 pass 하는 코드 작성하기
3. 리팩터링하기
위의 3가지를 계속 반복한다.

<Junit>
테스트코드 작성시 많이 사용되는 라이브러리

- 많이 사용되는 메서드
1. assertSame(a,b) : 두 객체 자체가 같은지 비교
2. assertEquals(a,b) : 두 객체에 정의된 equals를 통해 비교
3. assertArrayEquals(a,b) : 두 배열이 일치함을 확인
4. assertTrue(a) : 참인지 확인
5. assertNotNull(a) : null이 아닌지 확인





=============================== << DB에서 작업하기 >> ===============================
<Persistence Framework - SQL Mapper / ORM>
- Persistencd (영속성)
  : 데이터를 생성했던 프로그램이 종료되더라도 데이터가 휘발되지 않는 것.

- Persistence Framework
	: 데이터를 생성했던 프로그램이 종료되더라도 데이터가 휘발되지 않도록 도와주는 프레임워크
	: DB와 연동되는 시스템을 빠르게 개발(Spring, DB연결)
	  Persistence Framework가 없다면 SpringBoot와 DB와 연결하는 부분을 직접 관리해야 한다.
	  db와의 연결여부, query의 이상여부에 따라 if-else문으로 분기처리해야한다.
	  또한 db와 연결이 되어있는지 계속 확인해야 하고
	  db와 연결여부에 따라 if-else 분기처리해야한다.
	  그리고 db 사용이 끝나면 연결을 직접 끊어주어야한다.
	: 안정적인 구동을 보장해주는 프레임워크
	- 재사용, 유지보수에 용이
	- 직관적인 코드

1. SQL Mapper
	- SQL을 개발자가 직접 작성
	- 매핑 : 쿼리수행결과 <-> 객체
	- 단점
		- DB종류 변경시 쿼리 수정 필요
		- 비슷한 쿼리 반복적 작성 필요 ex) select * from 테이블명 -> 테이블마다 조회쿼리 작성 반복

2. ORM (Object Relation Mapping)
	- Object와 DB 테이블 맵핑
	- java 메서드 사용 -> 자동 SQL 생성.
	- 매핑 : DB테이블 <-> 객체
	- 단점
		- 복잡한 쿼리를 자바 메서드 만으로 해결하는 것이 불편.


<JPA / JDBC>
1. JPA (Java Persistence API)
	- ORM의 한 종류로 Java에서 사용.
	- 객체와 테이블의 연결된 정보만 알려주면 쿼리를 대신 짜줌.

	Application			O/R Mapper			JDBC interface		JDBC Implementations	Persistence Layer
	Modules
	---------------------------------------------------------------------------------------------------------
	service
	->repository---------> Spring Data JPA
						   -> JPA
	->repository Impl----> Hibernate -------> JDBC Basic APIs ---> JDBC Driver			Database
									 -------> DataSource -------->
											  (Configuration for connection)

2. JDBC (Java Database Connectivity)
	: 자바에서 DB를 사용할 수 있도록 제공해주는 최소한의 API.
	- SQL Mapper의 한 종류로 Java에서 사용.

	Application		JDBC interface		JDBC Implementations	Persistence Layer
	-----------------------------------------------------------------------------
	DTO				Spring JDBC			JDBC Driver				Database
					(ex> JdbcTemplate)

					DataSource
					(Configuration for connection)


<JDBC 사용하기>
1. build.gradle에 jdbc, mysql 관련 라이브러리 추가
   - implementation 'org.springframework.boot:spring-boot-starter-jdbc'
   - runtimeOnly 'com.mysql:mysql-connector-j'

2. application.properties 파일에 DB 접속정보 저장
   - 미설정 시 서버 실행 시 아래의 오류 발생
     Failed to configure a DataSource:
     'url' attribute is not specified and no embedded datasource could be configured.

3. MySQL에 데이터베이스, 테이블생성
   - Project 데이터베이스 생성
   - Memo 테이블 생성

4. 테이블과 매칭되는 자바 클래스 생성
   - Memo 테이블과 매칭되는 Memo.java 클래스(도메인) 생성

5. JdbcMemoRepository 생성
    - JDBC를 이용해 MySQL과 Spring 사이에 데이터 전송이 가능하도록 하기위해 저장소 생성.

